# DISCLAIMER: This script is generated by Gemini
# It works, so I wouldn't bother to carefully inspect if it actually does everything properly
import sys
import re
import subprocess
import os

# ==========================================
# CONFIGURATION: Fixed Manual WASI Replacements
# ==========================================
# NOTE: In WASI snapshot_preview1, almost ALL functions return i32 (errno).
# Even functions dealing with i64 (like time or file offsets) return i32
# and write their result to a pointer argument.

WASI_REPLACEMENTS = {
    # --- File System (Write) ---
    "fd_write": "    (i32.const 0)",
    "fd_pwrite": "    (i32.const 0)",
    "fd_sync": "    (i32.const 0)",
    "fd_datasync": "    (i32.const 0)",
    "fd_renumber": "    (i32.const 0)",
    "fd_allocate": "    (i32.const 0)",
    "fd_advise": "    (i32.const 0)",

    # --- File System (Read/Info) ---
    "fd_read": "    (i32.const 0)",
    "fd_pread": "    (i32.const 0)",
    # FIXED: Returns errno (i32), not offset (i64)
    "fd_seek": "    (i32.const 0)",
    "fd_tell": "    (i32.const 0)",      # FIXED: Returns errno (i32)
    "fd_fdstat_get": "    (i32.const 0)",
    "fd_fdstat_set_flags": "    (i32.const 0)",
    "fd_filestat_get": "    (i32.const 0)",
    "fd_filestat_set_size": "    (i32.const 0)",
    "fd_filestat_set_times": "    (i32.const 0)",
    "fd_readdir": "    (i32.const 0)",

    "path_open": "    (i32.const 0)",
    "path_filestat_get": "    (i32.const 0)",
    "path_filestat_set_times": "    (i32.const 0)",
    "path_link": "    (i32.const 0)",
    "path_rename": "    (i32.const 0)",
    "path_symlink": "    (i32.const 0)",
    "path_readlink": "    (i32.const 0)",

    # --- File System (Pre-stats / Initialization) ---
    # Return 8 (EBADF) implies "no such file/descriptor", stopping the RTS
    # from trying to use these descriptors further.
    "fd_prestat_get": "    (i32.const 8)",
    "fd_prestat_dir_name": "    (i32.const 8)",

    # --- File System (Management) ---
    "fd_close": "    (i32.const 0)",
    "path_create_directory": "    (i32.const 0)",
    "path_remove_directory": "    (i32.const 0)",
    "path_unlink_file": "    (i32.const 0)",

    # --- Environment ---
    "environ_get": "    (i32.const 0)",
    "environ_sizes_get": "    (i32.const 0)",
    "args_get": "    (i32.const 0)",
    "args_sizes_get": "    (i32.const 0)",

    # --- Clocks & Randomness ---
    "clock_time_get": "    (i32.const 0)",
    "clock_res_get": "    (i32.const 0)",
    "random_get": "    (i32.const 0)",

    # --- Process Control ---
    "proc_exit": "    (unreachable)",     # Trap!
    "sched_yield": "    (i32.const 0)",

    # --- Polling ---
    "poll_oneoff": "    (i32.const 0)",
}


def run_command(cmd, input_text=None):
    try:
        result = subprocess.run(
            cmd, input=input_text, capture_output=True, text=True, check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error running {' '.join(cmd)}:\n{e.stderr}")
        sys.exit(1)


def process_wasm(input_path, output_path):
    # 1. Convert Wasm -> WAT
    print(f"[1/4] Dumping {input_path} to WAT...")
    wat_content = run_command(["wasm-tools", "print", input_path])

    # 2. Process Line-by-Line
    # The regex finds the import line.
    # It captures:
    #   name: the function name
    #   func_def: everything from "(func" up to the end of the line
    line_pattern = re.compile(
        r'^\s*\(import\s+"wasi_snapshot_preview1"\s+"(?P<name>[^"]+)"\s+(?P<func_def>\(func\s+.*)\)\s*$'
    )

    new_lines = []
    stub_count = 0
    lines = wat_content.splitlines()

    for line in lines:
        match = line_pattern.match(line)
        if match:
            name = match.group("name")
            func_def_wrapped = match.group("func_def")

            if name not in WASI_REPLACEMENTS:
                print(
                    f"[ERROR] Unknown WASI import: '{name}'. Please add it to WASI_REPLACEMENTS.")
                sys.exit(1)

            # Strip the LAST parenthesis from the captured func definition
            # (import "..." "..." (func $id (type 0)))
            # func_def_wrapped is "(func $id (type 0))"
            current_def = func_def_wrapped.strip()

            if current_def.endswith(")"):
                # Remove the closing paren of the function
                prefix = current_def[:-1]
                body = WASI_REPLACEMENTS[name]
                # Reconstruct: func_def start + body + closing paren
                new_line = f"{prefix}\n{body}\n  )"
                new_lines.append(new_line)
                stub_count += 1
            else:
                print(f"[WARN] skipped malformed line: {line}")
                new_lines.append(line)
        else:
            new_lines.append(line)

    print(f"[2/4] Stubbed {stub_count} functions.")

    # 3. Convert WAT -> Wasm
    print(f"[3/4] Compiling back to {output_path}...")
    temp_wat = "temp_fixed.wat"
    with open(temp_wat, "w") as f:
        f.write("\n".join(new_lines))

    run_command(["wasm-tools", "parse", temp_wat, "-o", output_path])
    os.remove(temp_wat)
    print("[4/4] Done. Try loading this module now.")


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python replace_wasi.py <input.wasm> <output.wasm>")
        sys.exit(1)

    process_wasm(sys.argv[1], sys.argv[2])

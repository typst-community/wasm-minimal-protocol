# Haskell WASM plugin example

This is a bare-bone Typst plugin, written in Haskell.

## Compile

To compile this example, you need the GHC WebAssembly backend, as documented in [this link](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/wasm.html) and available from [this link](https://gitlab.haskell.org/haskell-wasm/ghc-wasm-meta).

The build script `build.sh` is made for Linux. Make sure that the GHC executable `wasm32-wasi-ghc` and the utility [`wasi-stub`](../../crates/wasi-stub) is on your `PATH`. Then, simply run the build script `build.sh`.

### Stubbing

Haskell is a language with a runtime system, and requires an explicit `hs_init()` call to initialize. In this initializer, it calls some of the WASI functions and expects reasonable outcomes.

Typst requires a standalone WebAssembly module does not use WASI functions. For this, [`wasi-stub`](../../crates/wasi-stub) is required to replace WASI functions with stubs. However, `wasi-stub` returns the arbitrary value `76` from the stubbed functions by default, which is bad since `hs_init()` expects reasonable return values from some WASI functions. As such, `wasi-stub` must be called with `--return-value 0`. This has been integrated into the build script.

## Build with Typst

Simply run `typst compile hello.typ`, and observe that it works!

Typst 0.14.0 or later is required to load `hello.wasm` generated by previous steps. If you are using an older version, you may encounter the following error:

> error: failed to load WebAssembly module (unexpected SIMD opcode: 0xfd (at offset 0x8b82))

## Note

Since Haskell has a runtime system, it is important that you not just load the Haskell-based Typst plugin, but also initialize it properly. You should write:
```
let p = plugin.transition(plugin("./hello.wasm").hs_init_wrapped)
```
in Typst, as opposed to `let p = plugin("./hello.wasm")` as seen in other languages' examples.